## 기획 파악

1. 상품 관리

- 상품
  id: 제품 id
  name: 제품 이름
  val: 가격
  q: 재고

- 재고
  재고가 없거나 부족하면 상품 비활설화

2. 장바구니

- 제품 추가
  재고가 있으면 장바구니에 추가

- 제품 삭제
  제품을 장바구니에서 제거

- 수량 조절
  장바구니에 있는 제품의 +,-버튼 수량 조절, **1이하면 장바구니에서 제거**

3. 프로모션

- 번개 세일
  랜덤 제품에 대해 일정 시간 간격으로 **20%** 할인
  **=> 사용자에게 알림**
  **=> 랜덤 시간으로 시작(10초 이후) => 30초 간격 실행**

- 추천 상품 할인
  마지막으로 선택한 제품 이외의 랜덤 제품에 대해 **5%** 추가 할인 프로모션
  **=> 사용자에게 알림**
  **=> 랜덤 시간으로 시작(20초 이후) => 60초 간격 실행**

1. 10개 이상 구매
   제품에 따른 할인율 적용
   **대량 구매와 중복 할인 없음**

2. 대량 구매 할인
   30개 이상 구매 시, 25% 대량 구매 할인 적용
   **25% 할인된 가격이 이전 할인된 가격보다 싸면 적용**
   **10개 이상 구매와 중복 할인 없음**

- 요일 할인
  화요일에는 전체 구매 금액에 **10%** 할인이 **추가** 적용

4. 결제 금액

- 총액
  장바구니에 담긴 제품들의 **_총 금액_**+**_할인 적용율_**+**_구매금액에 따른 적립포인트_** 표시

## 기본 과제 피드백

김나영 튜터 ・ 24.10.19(토)
200점드립니다. 매우 잘하셨습니다!
프레임워크와 유사한 구성으로 구현하시다보니 전체적으로 구성이 탄탄하고 깔끔합니다.

- 상태관리를 class로 구성하셔서 가독성이매우 올라가네요. 관리측면, 확장성측면에서도 좋구요
- 지난 과제의 로직들을 잘 활용하셨네요. 훌륭하십니다. (isEqual, ...)
- utils의 find와 interval은 비즈니스로직이 포함된 함수들이네요. util레벨보다는 service나 controller와같은 레이어로 분리하는 것이 좋을 듯 합니다. 물론 상원님이 정의하신 util의 의도가 순수함수만 모아두는 레이어가 아니라면 그대로 두셔도 되구요 ㅎㅎ

## 심화 과제 피드백

김나영 튜터 ・ 24.10.19(토)
기본과제에서 프레임워크 기반의 구성이다보니 React로 리팩토링시 수월했을 듯 합니다. 고생많으셨습니다.

- AlertPopUp보다는 내부에서 timeSale을 관리하고 있으니 좀더 비즈니스로직이 설명되는 네이밍으로 리팩토링해보셔더 좋을 듯 합니다.
- 데이터 구조가 현재는 모두 리스트 형태로 구성하셨는데요. 이부분을 다른 자료구조로 가져가는것도 고려해보셔도 좋습니다.
  재고나 카트에서 상품을 id기반으로 쿼리를 하고 있기 때문에 리스트형태보다 Map형태의 객체로 구성하신다면 update 액션이나 상품을 조회하여 정보를 얻는 액션에서 지금보다 코드를 좀더 최적화하실 수 있으실겁니다.

멘토링때 여쭤보셨던 질문은 해소되셨을까요? PR에 별도 질문이 없으셔서 여쭤봅니다. 아직 해소가 안되셨으면 PR에 request날려주셔도 좋습니다 (github id: @feel5ny)

## 느낌 점

> 리스트 데이터를 일반 객체보다 Map으로 수정하면 코드가 더 간결해 질 것같다 느껴서 진행 중에 문제점이 발생했다.

- Redux는 상태의 **직렬화 가능성**을 매우 중요하게 여기기 때문에 직렬화 불가능한 Map과 Set을 상태로 사용하는 것은 지양한다.
  따라서 직렬화 가능한 값(객체나 배열)을 사용하는 것이 권장되기 때문에 일반 객체로 구현했다.

굳이 Map, Set으로 구현한다면

- Map, Set으로 구현하려면 immer 패키지의 enableMapSet()함수를 써야한다.
- 상태를 업데이트할 때, 직렬화 가능한 객체나 배열로 변환 후, 상태를 저장해야 한다.
  ex)
  객체일 경우, const mapObj = Object.fromEntries({id:'p1',name:'상품1'})
  배열일 경우, const mapObj = Array.from([1,2,3,4,5])

기존에 Recoil을 사용해왔고 Redux를 처음 도입했는데, Redux는 React 렌더링 사이클에 매우 의존적이라는 점을 느꼈다.
정리하면

### recoil

---

- React 렌더링 사이클과 독립적으로 상태를 관리할 수 있다.
- 상태가 변경되어도 React 컴포넌트가 리렌더링 되지 않아도 된다.
- 상태를 구독하는 컴포넌트 외부에서도 자유롭데 상태를 다룰 수 있다.
- 상태와 컴포넌트의 의존성이 약하다. 즉, 상태 변경이 반드시 컴포넌트의 리렌더링을 유발하지 않는다.

### redux

---

- React 렌더링 사이클에 매우 의존적이다.
- 상태가 변경되면 리렌더링되며 useSelector를 통해 상태를 최신화한다.
- 중앙 집중식 상태 관리 방식을 채택하고 있으며, 상태 변경은 React 컴포넌트의 리렌더링과 밀접하게 연결되어 있다.

### Redux는 왜 직렬화 가능한 데이터 구조를 지향하는가?

---

1. Redux DevTools

   - 상태 변경 내역을 기록하고 undo/redo 형식으로 탐색 기능
   - 특정 시간의 상태로 돌아가는 기능 => Time Trabel Debug 기능
   - => 직렬화가 불가능한 데이터구조를 쓰면 데이터의 순서, 연속성 등 으로 인해 문제가 발생할 수 있다.

2. 미들웨어

   - 미들웨어는 액션과 상태를 직렬화하여 전송하는데 외부 서비스와 상호작용하는 작업에 문제가 생길 수 있다.

3. 통신
   - 상태를 직렬화 불가능한 데이터 구조로 관리할 경우, 서버와의 통신 시 상태를 전송하거나 수신하는 과정에서 변환 작업이 필요해지며, 이로 인해 불필요한 복잡성이 추가된다.

### Recoil의 직렬화가 필요하지 않은 이유

---

1. React의 상태 관리 방식을 확장

   - **useState**, **useReducer**와 같은 기본 React 상태 관리 함수들이 직렬화를 요구하지 않듯, Recoil도 상태를 직렬화하지 않고 컴포넌트의 로컬 상태처럼 사용

2. 중앙 집중식 상태 관리가 아닌 분산된 상태 관리
   - atom, selector

> 고민한 부분

Redux에 대한 지식이 부족하여 **setInterval**을 사용한 기존 구현에서 상태가 최신화되지 않는 문제가 발생했다.

1. intervalManager
   - 중앙에서 타이머를 관리하기 위해 설계했다.
   - 타이머 등록 후, custom hook내부에서 사용했으나, store값이 최신화되지 않는 문제 발생

#### 정상 작동

- 초기 상태 : { 상품1 ,가격: 10,000원 }
- 일정 시간 지나면 20% 할인 적용: 가격: 8,000원,
- 다시 일정 시간 지나면 20% 할인 적용: 가격: 6,400원이 되어야 한다.

#### 문제 상황

- 초기 상태 : { 상품1 ,가격: 10,000원 }
- 일정 시간 지나면 20% 할인 적용: 가격: 8,000원,
- 그러나 다시 일정 시간이 지나도 최신화되지 않은 초기 값(10,000원)이 참조됨: 가격이 다시 8,000원으로 유지됨

#### 문제 원인

- 클로저 문제: custom hook 내에서 참조되는 store값이 클로저에 의해 이전 값으로 고정되어 최신 값을 참조하지 못했다

> 해결 방법

- custom hook에서 store값을 인자로 받아 관리
- useRef 사용하여 최신값 유지
- useEffect 의존성 배열에 store 값 추가

> file:
> advaned/hooks/interval/useLightningInterval.ts
> advaned/hooks/interval/useSuggestionInterval.ts
